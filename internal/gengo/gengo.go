package gengo

import (
	"errors"
	"fmt"
	"io"
	"iter"
	"strconv"
	"strings"

	"github.com/romshark/icumsg"
	"golang.org/x/text/language"
)

const TypePrefixCatalog = "Catalog"

type Writer struct {
	w io.Writer      // Destination writer.
	l language.Tag   // Locale
	m string         // ICU message.
	t []icumsg.Token // ICU tokens.
	i int            // Current index in t.

	translatorVar string
}

var lineBreak = []byte("\n")

func (w *Writer) printf(format string, a ...any) {
	_, _ = fmt.Fprintf(w.w, format, a...)
	_, _ = w.w.Write(lineBreak)
}

func (w *Writer) print(format string) {
	_, _ = fmt.Fprint(w.w, format)
	_, _ = w.w.Write(lineBreak)
}

func (w *Writer) println(a ...any) {
	_, _ = fmt.Fprintln(w.w, a...)
}

type Message struct {
	TIK       string
	ICUMsg    string
	ICUTokens []icumsg.Token
}

var replacerCatalogSuffix = strings.NewReplacer("-", "_")

func localeToCatalogSuffix(t language.Tag) string {
	s := t.String()
	return strings.ToUpper(replacerCatalogSuffix.Replace(s))
}

// WritePackageBundle writes the main bundle Go file.
func (w *Writer) WritePackageBundle(
	writer io.Writer,
	packageName string,
	srcLocale language.Tag, translationLocales []language.Tag,
) {
	w.w, w.l = writer, srcLocale

	w.printf(`// Generated by github.com/romshark/toki. DO NOT EDIT.
package %s

import (
	"iter"

	"github.com/go-playground/locales"
	"github.com/romshark/toki"
)

const (
	minInt53 = -1 << 53
	maxInt53 = 1 << 53
)

func pluralRuleCardinal (t locales.Translator, quantity any) (locales.PluralRule) {
	var q float64
	switch n := quantity.(type) {
	case uint:
		if n >= maxInt53 {
			return locales.PluralRuleOther // Lossy conversion.
		}
		q = float64(n)
	case uint8:
		q = float64(n)
	case uint16:
		q = float64(n)
	case uint32:
		q = float64(n)
	case uint64:
		if n >= maxInt53 {
			return locales.PluralRuleOther // Lossy conversion.
		}
		q = float64(n)
	case int:
		if n >= maxInt53 || n <= minInt53 {
			return locales.PluralRuleOther // Lossy conversion.
		}
		q = float64(n)
	case int8:
		q = float64(n)
	case int16:
		q = float64(n)
	case int32:
		q = float64(n)
	case int64:
		if n >= maxInt53 || n <= minInt53 {
			return locales.PluralRuleOther // Lossy conversion.
		}
		q = float64(n)
	case float32:
		q = float64(n)
	case float64:
		q = float64(n)
	default:
		// Incorrect input type, fallback to other rule.
		return locales.PluralRuleOther
	}
	return t.CardinalPluralRule(float64(q), 0)
}

func pluralRuleOrdinal (t locales.Translator, quantity any) (locales.PluralRule) {
	var q float64
	switch n := quantity.(type) {
	case uint:
		if n >= maxInt53 {
			// Lossy conversion.
			return locales.PluralRuleOther
		}
		q = float64(n)
	case uint8:
		q = float64(n)
	case uint16:
		q = float64(n)
	case uint32:
		q = float64(n)
	case uint64:
		if n >= maxInt53 {
			// Lossy conversion.
			return locales.PluralRuleOther
		}
		q = float64(n)
	case int:
		if n >= maxInt53 || n <= minInt53 {
			// Lossy conversion.
			return locales.PluralRuleOther
		}
		q = float64(n)
	case int8:
		q = float64(n)
	case int16:
		q = float64(n)
	case int32:
		q = float64(n)
	case int64:
		if n >= maxInt53 || n <= minInt53 {
			// Lossy conversion.
			return locales.PluralRuleOther
		}
		q = float64(n)
	case float32:
		q = float64(n)
	case float64:
		q = float64(n)
	default:
		// Incorrect input type, fallback to default form.
		return locales.PluralRuleOther
	}
	return t.OrdinalPluralRule(float64(q), 0)
}

func subtract(number any, amount uint) any {
	switch v := number.(type) {
	case int:
		return v - int(amount)
	case uint:
		return v - uint(amount)
	case int8:
		return v - int8(amount)
	case uint8:
		return v - uint8(amount)
	case int16:
		return v - int16(amount)
	case uint16:
		return v - uint16(amount)
	case int32:
		return v - int32(amount)
	case uint32:
		return v - uint32(amount)
	case int64:
		return v - int64(amount)
	case uint64:
		return v - uint64(amount)
	case float64:
		return v - float64(amount)
	case float32:
		return v - float32(amount)
	default:
		return number
	}
}`, packageName)

	w.println("// Bundle bundles all currently enabled translations.")
	w.println("type Bundle struct {}")
	w.println("var _ toki.Bundler = Bundle{}")

	w.println("// Catalogs returns an iterator over all enabled catalogs.")
	w.println("func (Bundle) Catalogs() iter.Seq[toki.Reader] {")
	w.println("return func(yield func(toki.Reader) bool) {")
	for _, l := range translationLocales {
		suffix := localeToCatalogSuffix(l)
		typeName := TypePrefixCatalog + suffix
		w.printf("if !yield(%s{}) { return }\n", typeName)
	}
	w.println("}}")
}

func goPlaygroundLocalesPkg(locale language.Tag) string {
	return replacerCatalogSuffix.Replace(locale.String())
}

// WritePackageCatalog writes a catalog Go file.
func (w *Writer) WritePackageCatalog(
	writer io.Writer, locale language.Tag, packageName string, msgIter iter.Seq[Message],
) {
	w.w, w.l = writer, locale

	w.println("// Generated by github.com/romshark/toki. DO NOT EDIT.")
	w.printf("package %s\n", packageName)
	w.println("import (")
	w.println("\t" + `"fmt"`)
	w.println("\t" + `"strings"`)
	w.println("")
	w.printf("\tlocales \"github.com/go-playground/locales\"")
	w.printf("\t locale \"github.com/go-playground/locales/%s\"",
		goPlaygroundLocalesPkg(locale))
	w.println("\ttoki" + `"github.com/romshark/toki"`)
	w.println("\tlanguage" + `"golang.org/x/text/language"`)
	w.println(")") // End of imports.

	w.writeCatalogType(msgIter)
}

func (w *Writer) writeCatalogType(msgIter iter.Seq[Message]) {
	localeCatalogSuffix := localeToCatalogSuffix(w.l)
	w.translatorVar = fmt.Sprintf("Translator%s", localeCatalogSuffix)
	w.printf("\n"+`var locale%s language.Tag`+"\n", localeCatalogSuffix)
	w.printf("\n"+`var %s = locale.New()`+"\n", w.translatorVar)

	w.printf(`func init() {
	var err error
	locale%s, err = language.Parse(%q)
	if err != nil {
		// This should never happen because the locale string value
		// is validated before code generation.
		panic(err)
	}
}`, localeCatalogSuffix, w.l.String())

	// Type definition.
	catalogTypeName := TypePrefixCatalog + localeCatalogSuffix
	w.printf("// %s provides localization for %s.", catalogTypeName, w.l.String())
	w.printf("type %s struct {}\n", catalogTypeName)
	w.printf("var _ toki.Reader = %s{}\n", catalogTypeName)

	// Translation functions by TIK.
	translationsVarMapName := "translations" + localeCatalogSuffix
	w.printf(`var %s = map[string]func(args ...any) string {`, translationsVarMapName)
	for msg := range msgIter {
		w.writeFunc(msg.TIK, msg.ICUMsg, msg.ICUTokens)
	}
	w.println(`}`)

	// Method Locale.
	w.println(`// Locale returns the locale c provides localization for.`)
	w.printf("func (%s) Locale() language.Tag { return locale%s }\n",
		catalogTypeName, localeCatalogSuffix)

	// Method Translator.
	w.println(`// Translator returns the localized translator.`)
	w.printf("func (%s) Translator() locales.Translator { return %s }\n",
		catalogTypeName, w.translatorVar)

	// Method Text.
	w.println(`// Text returns localized text for the given TIK.`)
	w.printf("func (%s) Text(tik string, args ...any) string {",
		catalogTypeName)
	w.writeMethodText(translationsVarMapName)
	w.print("}\n\n")
}

func (w *Writer) writeMethodText(translationsVarMapName string) {
	w.printf("f := %s[tik]", translationsVarMapName)
	w.printf(`if f == nil { panic("TODO") }`)
	w.print("return f(args...)")
}

// writeFunc writes a translation function as a map entry.
func (w *Writer) writeFunc(tik, icuMsg string, tokens []icumsg.Token) {
	w.m = icuMsg
	w.t = tokens
	w.i = 0

	w.printf("%q:", tik)
	w.printf("func(args ...any) string {")
	w.println("var b strings.Builder;")
	w.writeExpr(len(w.t))
	w.println("return b.String();},")
}

var ErrUnsupportedArgName = errors.New("unsupported argument name")

func (w *Writer) writeExpr(endIndex int) {
	for w.i < endIndex {
		t := w.t[w.i]
		switch t.Type {
		case icumsg.TokenTypeLiteral:
			w.printf("_, _ = b.WriteString(%q);", t.String(w.m, w.t))
			w.i++ // Advance.
		case icumsg.TokenTypeSimpleArg:
			w.writeSimpleArg()
		case icumsg.TokenTypePlural, icumsg.TokenTypeSelectOrdinal:
			w.writePlural(false)
		case icumsg.TokenTypeArgTypeOrdinal:
			w.writePlural(true)
		case icumsg.TokenTypeSelect:
			w.writeSelect()
		default:
			// This should never happen since writeExpr is always
			// called on the above mentioned token types.
			panic(t.Type.String())
		}
	}
}

func (w *Writer) writeSimpleArg() {
	argNameToken := w.t[w.i+1].String(w.m, w.t)
	arg, err := parseArgName(argNameToken)
	if err != nil {
		// This should never happen because argument names are checked
		// before the Go bundle code is generated.
		panic(err)
	}
	tokType := w.t[w.i+2]
	if !isTokenArgType(tokType.Type) {
		// No argument type.
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		w.i += 2
		return
	}

	tokStyle := w.t[w.i+3]
	if !isTokenArgStyle(tokStyle.Type) {
		// Argument type only.
		w.i += 3
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	}
	// Has argument type and style parameters.
	_ = tokStyle
	w.i += 4
	switch tokStyle.Type {
	case icumsg.TokenTypeArgStyleShort:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleMedium:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleLong:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleFull:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleInteger:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleCurrency:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStylePercent:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	case icumsg.TokenTypeArgStyleCustom:
		// TODO
		w.printf("_, _ = fmt.Fprintf(&b, %q, args[%d]);", `%v`, arg.Index)
		return
	default:
		// This should never happen because this switch is exhaustive.
		panic(tokStyle.Type.String())
	}
}

func (w *Writer) writePlural(ordinal bool) {
	t := w.t[w.i]
	argNameToken := w.t[w.i+1].String(w.m, w.t)
	argIndex, err := parseArgName(argNameToken)
	if err != nil {
		return
	}

	offset := uint64(0)
	if ot := w.t[w.i+2]; ot.Type == icumsg.TokenTypePluralOffset {
		// Has offset parameter.
		s := ot.String(w.m, w.t)
		if offset, err = strconv.ParseUint(s, 10, 64); err != nil {
			// This should never happen because the offset number
			// is validated when the ICU message is parsed.
			panic(err)
		}
	}

	getterFunc := "pluralRuleCardinal"
	if ordinal {
		getterFunc = "pluralRuleOrdinal"
	}

	var iOther, iZero, iOne, iTwo, iFew, iMany int
	for i := range icumsg.Options(w.t, w.i) {
		switch w.t[i].Type {
		case icumsg.TokenTypeOptionZero:
			iZero = i
		case icumsg.TokenTypeOptionOne:
			iOne = i
		case icumsg.TokenTypeOptionTwo:
			iTwo = i
		case icumsg.TokenTypeOptionFew:
			iFew = i
		case icumsg.TokenTypeOptionMany:
			iMany = i
		case icumsg.TokenTypeOptionOther:
			iOther = i
		}
	}

	w.printf("switch %s(%s, args[%d]) {",
		getterFunc, w.translatorVar, argIndex.Index)
	if iZero != 0 {
		w.println("case locales.PluralRuleZero:")
		w.i = iZero
		w.writePluralOption(argIndex, offset)
	}
	if iOne != 0 {
		w.println("case locales.PluralRuleOne:")
		w.i = iOne
		w.writePluralOption(argIndex, offset)
	}
	if iTwo != 0 {
		w.println("case locales.PluralRuleTwo:")
		w.i = iTwo
		w.writePluralOption(argIndex, offset)
	}
	if iFew != 0 {
		w.println("case locales.PluralRuleFew:")
		w.i = iFew
		w.writePluralOption(argIndex, offset)
	}
	if iMany != 0 {
		w.println("case locales.PluralRuleMany:")
		w.i = iMany
		w.writePluralOption(argIndex, offset)
	}
	if iOther != 0 {
		w.println("default:")
		w.i = iOther
		w.writePluralOption(argIndex, offset)
	}
	w.print("};")
	w.i = t.IndexEnd + 1 // Skip the whole block.
}

func (w *Writer) writePluralOption(arg argName, offset uint64) {
	indexEnd := w.t[w.i].IndexEnd
	defer func() { w.i = indexEnd + 1 }()
	w.i++
	for w.i < indexEnd {
		t := w.t[w.i]
		switch t.Type {
		case icumsg.TokenTypeLiteral:
			for s := range iterPluralLiteralParts(t.String(w.m, w.t)) {
				if s == "#" {
					if offset != 0 {
						w.printf(
							"_, _ = fmt.Fprintf(&b, %q, subtract(args[%d], %d));", "%v",
							arg.Index, offset,
						)
						continue
					} else {
						w.printf(
							"_, _ = fmt.Fprintf(&b, %q, args[%d]);", "%v", arg.Index,
						)
						continue
					}
				}
				w.printf("_, _ = b.WriteString(%q);", s)
			}
			w.i++
		case icumsg.TokenTypeSimpleArg:
			w.writeSimpleArg()
		case icumsg.TokenTypePlural,
			icumsg.TokenTypeSelect,
			icumsg.TokenTypeSelectOrdinal:
			w.writeExpr(indexEnd)
			w.i = t.IndexEnd + 1
		default:
			w.i++
		}
	}
}

func (w *Writer) writeSelect() {
	t := w.t[w.i]
	argNameToken := w.t[w.i+1].String(w.m, w.t)
	argIndex, err := parseArgName(argNameToken)
	if err != nil {
		return
	}

	w.printf("switch args[%d].(string) {", argIndex.Index)
	for i := range icumsg.Options(w.t, w.i) {
		if w.t[i].Type == icumsg.TokenTypeOptionOther {
			// Default case.
			w.println("default:")
			w.i = i + 1
			w.writeExpr(w.t[i].IndexEnd)
			continue
		}
		// Named case.
		optionValStr := w.t[i+1].String(w.m, w.t)
		w.printf("case %q:", optionValStr)
		w.i = i + 2
		w.writeExpr(w.t[i].IndexEnd)
	}
	w.print("};")
	w.i = t.IndexEnd + 1 // Skip the whole block.
}

type argName struct {
	Index  int
	Gender bool
}

func parseArgName(s string) (argName, error) {
	if len(s) < 2 || s[0] != '_' {
		return argName{}, fmt.Errorf("%w: %q", ErrUnsupportedArgName, s)
	}
	gender := strings.HasSuffix(s, "_gender")

	v, err := strconv.ParseUint(s[1:], 10, 32)
	if err != nil {
		return argName{}, err
	}
	return argName{Index: int(v), Gender: gender}, nil
}

func isTokenArgType(t icumsg.TokenType) bool {
	return t >= icumsg.TokenTypeArgTypeNumber && t <= icumsg.TokenTypeArgTypeDuration
}

func isTokenArgStyle(t icumsg.TokenType) bool {
	return t >= icumsg.TokenTypeArgStyleShort && t <= icumsg.TokenTypeArgStyleCustom
}

func iterPluralLiteralParts(s string) iter.Seq[string] {
	return func(yield func(string) bool) {
		for {
			i := strings.IndexByte(s, '#')
			if i == -1 {
				if s != "" {
					yield(s) // Yield last part.
				}
				return
			}
			if i > 0 {
				if !yield(s[:i]) { // Yield part before #.
					return
				}
			}
			if !yield("#") {
				return
			}
			s = s[i+1:] // Continue after #.
		}
	}
}
