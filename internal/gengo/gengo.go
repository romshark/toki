package gengo

import (
	_ "embed"
	"errors"
	"fmt"
	"io"
	"iter"
	"maps"
	"slices"
	"strconv"
	"strings"

	"github.com/romshark/toki/internal/codeparse"

	"github.com/romshark/icumsg"
	"golang.org/x/text/language"
)

const TypePrefixCatalog = "catalog_"

type Writer struct {
	tokiVersion string

	scan    *codeparse.Scan
	msgIter iter.Seq[Message]
	w       io.Writer      // Destination writer.
	l       language.Tag   // Locale
	m       string         // ICU message.
	t       []icumsg.Token // ICU tokens.
	i       int            // Current index in t.

	translatorVar string
}

func NewWriter(tokiVersion string, scan *codeparse.Scan) *Writer {
	return &Writer{
		tokiVersion: tokiVersion,
		scan:        scan,
		msgIter:     newMsgIter(scan),
	}
}

var lineBreak = []byte("\n")

func (w *Writer) printf(format string, a ...any) {
	_, _ = fmt.Fprintf(w.w, format, a...)
}

func (w *Writer) print(format string) {
	_, _ = fmt.Fprint(w.w, format)
	_, _ = w.w.Write(lineBreak)
}

func (w *Writer) println(a ...any) {
	_, _ = fmt.Fprintln(w.w, a...)
}

type Message struct {
	ID        string
	TIK       string
	ICUMsg    string
	ICUTokens []icumsg.Token
}

func newMsgIter(scan *codeparse.Scan) iter.Seq[Message] {
	var nativeCatalog *codeparse.Catalog
	for c := range scan.Catalogs.Seq() {
		if c.ARB.Locale == scan.DefaultLocale {
			nativeCatalog = c
			break
		}
	}
	if nativeCatalog == nil {
		return func(yield func(Message) bool) {}
	}
	return func(yield func(Message) bool) {
		sorted := slices.Sorted(maps.Keys(nativeCatalog.ARB.Messages))
		for _, msgID := range sorted {
			m := nativeCatalog.ARB.Messages[msgID]
			txt := scan.Texts.At(scan.TextIndexByID.GetValue(msgID))
			if !yield(Message{
				ID:        txt.IDHash,
				TIK:       txt.TIK.Raw,
				ICUMsg:    m.ICUMessage,
				ICUTokens: m.ICUMessageTokens,
			}) {
				break
			}
		}
	}
}

var replacerCatalogSuffix = strings.NewReplacer("-", "_")

func localeToCatalogSuffix(t language.Tag) string {
	s := t.String()
	return strings.ToLower(replacerCatalogSuffix.Replace(s))
}

func FileNameWithLocale(t language.Tag, prefix, extension string) string {
	s := localeToCatalogSuffix(t)
	return fmt.Sprintf("%s_%s%s", prefix, s, extension)
}

//go:embed template.go.txt
var templateGoTxt string

// WritePackageBundle writes the main bundle Go file.
func (w *Writer) WritePackageBundle(
	writer io.Writer, packageName string, headTxtLines []string,
) {
	w.w, w.l = writer, w.scan.DefaultLocale

	// This header is very important. Toki relies on it to detect its generated files.
	w.printf("// Generated by github.com/romshark/toki. DO NOT EDIT.\n")
	for _, l := range headTxtLines {
		w.printf("// %s\n", l)
	}
	w.printf(templateGoTxt, packageName, w.tokiVersion, w.scan.DefaultLocale.String())

	w.println("// Catalogs returns an iterator over all enabled catalogs.")
	w.println("func Catalogs() iter.Seq[Reader] {")
	w.println("return func(yield func(Reader) bool) {")
	for c := range w.scan.Catalogs.Seq() {
		suffix := localeToCatalogSuffix(c.ARB.Locale)
		typeName := TypePrefixCatalog + suffix
		w.printf("if !yield(%s{}) { return }\n", typeName)
	}
	w.println("}}")

	// TIKs
	w.println("// TIKs")
	w.printf("const (\n")
	for msg := range w.msgIter {
		w.printf("\t%s = `%s`\n", msg.ID, msg.TIK)
	}
	w.println(`)`)
}

func goPlaygroundLocalesPkg(locale language.Tag) string {
	return replacerCatalogSuffix.Replace(locale.String())
}

// WritePackageCatalog writes a catalog Go file.
func (w *Writer) WritePackageCatalog(
	writer io.Writer, locale language.Tag, packageName string, headTxtLines []string,
) {
	w.w, w.l = writer, locale

	w.println("// Generated by github.com/romshark/toki. DO NOT EDIT.")
	for _, l := range headTxtLines {
		w.printf("// %s\n", l)
	}
	w.printf("\npackage %s\n", packageName)
	w.println("import (")
	w.println("\t" + `"fmt"`)
	w.println("\t" + `"io"`)
	w.println("\t" + `"time"`)
	w.println("")
	w.printf("\tlocales \"github.com/go-playground/locales\"\n")
	w.printf("\t locale \"github.com/go-playground/locales/%s\"\n",
		goPlaygroundLocalesPkg(locale))
	w.println("\tlanguage" + `"golang.org/x/text/language"`)
	w.println(")") // End of imports.

	w.writeCatalogType(w.msgIter)
}

func (w *Writer) writeCatalogType(msgIter iter.Seq[Message]) {
	localeCatalogSuffix := localeToCatalogSuffix(w.l)
	w.translatorVar = fmt.Sprintf("tr_%s", localeCatalogSuffix)
	w.printf("\n// This prevents the \"imported and not used\" error " +
		"when some features are not used.\n")
	w.printf("var _ fmt.Formatter = nil\n")
	w.printf("var _ time.Time\n")
	w.printf("\nvar %s = locale.New()\n", w.translatorVar)

	// Type definition.
	catalogTypeName := TypePrefixCatalog + localeCatalogSuffix
	w.printf("type %s struct {}\n", catalogTypeName)

	// Translation functions map by TIK based on io.Writer.
	writersMapName := "writers_" + localeCatalogSuffix
	w.printf(
		"var %s = map[string]func(w io.Writer, args ...any) (int, error) {\n",
		writersMapName)
	for msg := range msgIter {
		w.writeFunc(msg.ID, msg.ICUMsg, msg.ICUTokens)
	}
	w.println(`}`)

	// Method Locale.
	w.printf("func (%s) Locale() language.Tag { return language.MustParse(%q) }\n\n",
		catalogTypeName, localeCatalogSuffix)

	// Method Translator.
	w.printf("func (%s) Translator() locales.Translator { return %s }\n\n",
		catalogTypeName, w.translatorVar)

	// Method String.
	w.printf("func (%s) String(tik string, args ...any) string {\n",
		catalogTypeName)
	w.println(`b := poolBufGet()`)
	w.println(`defer poolBufPut(b)`)
	w.printf("f := %s[tik];\n", writersMapName)
	w.println(`if f == nil { _, _ = MissingTranslation(b, tik, args...);`)
	w.println(`} else { _, _ = f(b, args...);`)
	w.println(`}`)
	w.println(`return b.String()`)
	w.print("}\n\n")

	// Method Write.
	w.printf("func (%s) Write(\nwriter io.Writer, tik string, args ...any,\n)"+
		" (written int, err error) {\n",
		catalogTypeName)
	w.printf("f := %s[tik];\n", writersMapName)
	w.println(`if f == nil { return MissingTranslation(writer, tik, args...) }`)
	w.print("return f(writer, args...)")
	w.print("}\n\n")
}

var ErrUnsupportedArgName = errors.New("unsupported argument name")

// literalConcat returns "" if message isn't just a sequence
// of literal tokens.
func (w *Writer) literalConcat(endIndex int) string {
	l := 0
	for i := w.i; i < endIndex; i++ {
		t := w.t[i]
		switch t.Type {
		case icumsg.TokenTypeLiteral:
			l += len(t.String(w.m, w.t))
		default:
			return "" // Not a sequence of literals, abort.
		}
	}

	var s strings.Builder
	s.Grow(l)
	for i := w.i; i < endIndex; i++ {
		t := w.t[i]
		if t.Type == icumsg.TokenTypeLiteral {
			s.WriteString(t.String(w.m, w.t))
		}
	}
	return s.String()
}

type argName struct {
	Index  int
	Gender bool
}

func parseArgName(s string) (argName, error) {
	if len(s) < len("var0") || !strings.HasPrefix(s, "var") {
		return argName{}, fmt.Errorf("%w: %q", ErrUnsupportedArgName, s)
	}
	gender := strings.HasSuffix(s, "_gender")

	endIndex := len("var0")
	for i := range s[endIndex:] {
		if s[i] < '0' || s[i] > '9' {
			endIndex += i
			break
		}
	}

	v, err := strconv.ParseUint(s[len("var"):endIndex], 10, 32)
	if err != nil {
		return argName{}, err
	}
	return argName{Index: int(v), Gender: gender}, nil
}

func isTokenArgType(t icumsg.TokenType) bool {
	return t >= icumsg.TokenTypeArgTypeNumber && t <= icumsg.TokenTypeArgTypeDuration
}

func isTokenArgStyle(t icumsg.TokenType) bool {
	return t >= icumsg.TokenTypeArgStyleShort && t <= icumsg.TokenTypeArgStyleSkeleton
}

func iterPluralLiteralParts(s string) iter.Seq[string] {
	return func(yield func(string) bool) {
		for {
			i := strings.IndexByte(s, '#')
			if i == -1 {
				if s != "" {
					yield(s) // Yield last part.
				}
				return
			}
			if i > 0 {
				if !yield(s[:i]) { // Yield part before #.
					return
				}
			}
			if !yield("#") {
				return
			}
			s = s[i+1:] // Continue after #.
		}
	}
}
